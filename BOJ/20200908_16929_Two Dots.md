### 문제

 [Two Dots  백준 16929번](https://www.acmicpc.net/problem/16929)

</br>

### 리뷰

처음에 BFS로 시도했는데, 문제의 에제 입출력 4개중에 3개만 맞아서 멘붕이 왔다. 

```c++
3 4
AAAA
ABCA
AADA // 이건 사이클이 없는데. "Yes"를 출력한다... 
```

그래서 [사이클 관련 질문게시판 글](https://www.acmicpc.net/board/view/50657)을 읽고 DFS로 시도해봤다. 



 

</br>

### 코드

```c++
#include <iostream> 
#include <queue>
#include <cstring> // memset()
#include <algorithm> // min(), pair STL
using namespace std;


char B[51][51]; //지도  
int check[51][51]; //방문 표시 지도
int N, M;   // 행, 열  

// 4방향 
int dx[5] = {-1, 1, 0, 0}; 
int dy[5] = {0, 0, -1, 1};


// 지도 범위 내에 있는지 확인
bool boundary(int i, int j){   
	return (i >= 0 && i < N && j >= 0 && j < M) ? 1:0;
} 
 
string BFS(int start_x, int start_y, char color){

	// q : 좌표, 이동횟수 저장 
	queue<pair<pair<int,int>, int>> q;
	
	q.push({ {start_x, start_y}, 1 }); // 좌표와 점 개수   
	check[start_x][start_y] = 1;   
	  
	while(!q.empty()){
		
		int now_x = q.front().first.first;
		int now_y = q.front().first.second;
		int cnt = q.front().second;
		q.pop();
		
		// 4방향 확인 
		for(int i = 0; i < 4; i++){
		
			int next_x = now_x + dx[i];
			int next_y = now_y + dy[i];
			
			if(boundary(next_x, next_y)){ // 범위 내부인지 
				 
				// 같은색인지 && 미방문인지  
				if(B[next_x][next_y] == color && check[next_x][next_y] == 0) { 
					
					q.push({ {next_x, next_y}, cnt+1 }); // 좌표와 점 개수   
					check[next_x][next_y] = 1;  // 방문 표시  
					
					if(4 <= cnt && (start_x == next_x  || start_y==next_y) ){ // 시작점과 현재지점이 인접한지 검사  
						return "Yes";  
					}
				}
				  
			}
		} 	
	}
	
	return "No";
} 
 
int main(void){

    freopen("input.txt", "rt", stdin);
 	
 	cin >> N >> M; // 행, 열 
	 
	for(int i = 0; i <N; i++){
		for(int j = 0; j < M; j++){
			cin >> B[i][j];
		}
	} // 입력받기 끝 
 	
	string res = "No";
	
	for(int i = 0; i <N; i++){ // 모든 지점에서 BFS 시작  
		for(int j = 0; j < M; j++){
		
			string st = BFS(i, j, B[i][j]);
 			
			if(st == "Yes"){
				res = "Yes";
				break;
			}
			
			memset(check, 0, sizeof(check)); 
		}
	} 
	
	cout << res;
	 
	return 0;	
}
```



