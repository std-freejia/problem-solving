### 문제

[A/B  백준 1008번](https://www.acmicpc.net/problem/1008)

</br>

### 리뷰

A/B를 출력한다. 

**실제 정답과 출력값의 절대오차 또는 상대오차가 10-9 이하이면 정답이다.**

</br>

10-9 이하의 오차를 허용한다는 말은 꼭 소수 9번째 자리까지만 출력하라는 뜻이 아니다.

질문 게시판 글](https://www.acmicpc.net/board/view/47851)을 읽으면서 배운 것이 많은 문제다. 

실수형을 해야 하니까 자료형은 double을 했다. 

printf의 포맷스트링이 관건이다. 

10의 -9승 이하의 오차를 허용한다는 말은 **10의 -9승 보다 더 자세하게 표현하라**는 것과 같은 말이다. 

```c++
// 예시 입력  1/3   
// 출력은 0.333 이 아니다. 

0.33333333333333333333333333333333
    
```

double형 출력 할 때 포맷스트링

```c++
printf("%lf", A/B);

/* double 형 포맷스트링  %lf 는 기본적으로 출력할 때 유효숫자가 6 이다.
10의 -9승 보다 자세히 출력하려면  .12lf 와 같이 자리수를 명시해야 한다. 
*/

printf("%.10lf", A/B); // 소수 1e-11의 자리에서 반올림
```

</br> 

#### 참고

[포맷스트링 f와 g 관련 댓글[(https://www.acmicpc.net/board/view/49527)

```c++
printf("%.9g") // 가수부의 개수를 9개로 제한하는 표현

// 예를 들어 11.1234567891 의 경우

printf("%.9f")  는 11.123456789 가 나오겠지만 

printf("%.9g")  는 11.1234568이 나올겁니다. 

가수부가 정수부분 2개(11)와 소수부분 7개(.1234567)로 되기 때문이다.
```

</br>

### 맞은 코드 

```c++
#include <iostream>
using namespace std;

double A, B; 

int main(){
	
	cin >> A >> B;

	printf("%.10lf", A/B); // 소수 1e-11의 자리에서 반올림
	
	return 0;
}
```

</br>