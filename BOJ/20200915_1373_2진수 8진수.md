### 문제

[2진수 8진수  백준 1373번](https://www.acmicpc.net/problem/1373)

</br>

### 리뷰

 2진수의 3 자리를 8진수의 1 자리로 만들 수 있다.

예를 들어 2진수 11001100 이 있다. 

맨 오른쪽 부터 **2의 0승, 2의 1승, 2의 2승**이 곱해진 수다.  ( 4, 2, 1)

3의 배수의 길이일때 이것이 성립한다. 

11001100은 길이가 8이다. 8진수로 계산할 때는 11 001 100 으로 나눠질 수 있다. 

첫번째 1과 두번째 1은 따로 처리해줘야 한다. 

```c++
11 001 100 

11 을 8진수로 바꾼다. 
(2^1)x 1  + (2^0)x 1   // 2자리 일때는 2의 1승부터 시작!
    = 2 + 1 
    = 3 
    
001 을 8진수로 바꾼다. 
(2^2)x 0  + (2^1)x 0  +  (2^0)x 1   // 3자리 일때는 2의 2승부터 시작!
    = 0 + 0 + 1
    = 1    

100 을 8진수로 바꾼다. 
(2^2)x 1  + (2^1)x 0  +  (2^0)x 0 
    = 4 + 0 + 0
    = 4
```

</br>

이진수 문자열 길이가 4, 5, 6인 세 가지 경우가 있다. 

이진수 문자열 길이가 4인 경우,  (길이 % 3 == 1)

맨 앞의 수를  (2^0)x  ?  으로 계산해주고,  

나머지 3개의 수를 (2^2)x ?  + (2^1)x ?  +  (2^0)x ?   식으로 계산하면 된다.

</br>

 

### 맞은 코드 

```c++
#include <iostream> 
#include <cstring> //strlen() 
using namespace std;

char ch[1000001];

int main(void){
 
	scanf("%s", &ch); 
	
	int len = strlen(ch);
	
	if(len % 3 == 1){
		printf("%d", ch[0]-48 );
		
	}else if(len % 3 == 2){
		printf("%d",  2*( ch[0]-48 ) + ch[1]-48 );
	}	
	
	// 나머지 3의 배수로 떨어지는 길이만큼. len%3으로 시작해야 한다.
	for(int i = len%3; i < len; i += 3 ){
		printf("%d", 4 * ( ch[i]-48 ) +   2 * ( ch[i+1]-48 ) +  ch[i+2]-48 );
	}
		
	return 0;	
} 
```

 </br>
