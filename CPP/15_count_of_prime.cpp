#include <stdio.h> 

// 15. 소수의 개수 count_of_prime 

/*
N개의 자자연수 N이 입력되면 1부터 N까지의 소수의 개수를 출력하는 프로그램을 작성하세요.

만약 20이 입력되면 1부터 20까지의 소수는 2, 3, 5, 7, 11, 13, 17, 19로 총 8개입니다.

제한시간은 1초입니다. 

input.txt
20
*/

int arr[200001];
	
int main(int argc, char** argv) {
	
	int num = 0, cnt = 0, flag = 1, i=0, j=0;

	freopen("input.txt", "rt", stdin);	
	scanf("%d", &num);
	
	// flag가 1이면 소수  
	for(i=2; i<=num; i++){
		flag = 1; // 일단 소수라고 가정. 
		
		for(j=2; j*j<=i; j++){ 		// i 까지 약수가 존재 하는지 검사  
			if(i%j == 0){ // j는 i의 약수.  
				flag = 0;  // 약수가 존재하니까 소수가 아니다. 
				break; 
			}
		} 
		
		if(flag==1){ // 소수라면,  개수 센다.  
			cnt++;
		} 
	}

	printf("%d", cnt);
	
	return 0;
}

/* 문제 해설  num = 36인 경우. 

1과 자기 자신을 제외하고 36의 약수가 나타나면 flag를 0으로 표시한다.

1 X 36 = 36
2 X 18 = 36  // 36의 가장 큰 약수는 자기 자신의 절반 (18) 이다.  
3 X 12 
4 X 9 
6 X 6

즉, 36의 제곱근인 6까지만 약수가 존재하는지 확인하면 된다. 
2, 3, 4, 6 까지만 나눠보자. 
그러면 반대편 9, 12, 18 이라는 약수가 이미 있는 것이다. (안해봐도 되는 부분)

i 의 제곱근 까지 하면 된다. 
j의 제곱이라고 표현해도 같은 효과가 난다. 

j < i의 제곱근 
j 의 제곱 < i 
 
 */ 

